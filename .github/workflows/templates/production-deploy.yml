name: Production Deployment

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string
        description: 'Name of the service to deploy'
      docker_image:
        required: true
        type: string
        description: 'Docker image name'
      docker_tag:
        required: true
        type: string
        description: 'Docker image tag'
      working_directory:
        required: false
        type: string
        description: 'Directory containing the service code'
        default: 'services/${{ inputs.service_name }}'
      run_migrations:
        required: false
        type: boolean
        default: false
        description: 'Whether to run database migrations'
      deployment_strategy:
        required: false
        type: string
        default: 'blue-green'
        description: 'Deployment strategy to use (blue-green, canary, rolling)'
      canary_percentage:
        required: false
        type: number
        default: 20
        description: 'Percentage of traffic to route to canary for canary deployments'
      enable_auto_rollback:
        required: false
        type: boolean
        default: true
        description: 'Whether to enable automatic rollback on failure'
      approval_timeout:
        required: false
        type: number
        default: 1800
        description: 'Timeout for approval in seconds (30 minutes default)'
    secrets:
      KUBECONFIG_DATA:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      API_TOKEN:
        required: true
      VAULT_TOKEN:
        required: true
    outputs:
      deploy_success:
        description: 'Whether the deployment was successful'
        value: ${{ jobs.deploy_production.outputs.deploy_success }}
      service_url:
        description: 'URL of the deployed service'
        value: ${{ jobs.deploy_production.outputs.service_url }}
      deployment_id:
        description: 'ID of the deployment'
        value: ${{ jobs.deploy_production.outputs.deployment_id }}

jobs:
  security_scan:
    name: Production Security Scan ${{ inputs.service_name }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Run Security Scan
        uses: ./.github/workflows/templates/security.yml
        with:
          service_name: ${{ inputs.service_name }}
          working_directory: ${{ inputs.working_directory }}
          scan_level: 'compliance'
          fail_on_severity: 'high'

  # Validate infrastructure before deploying
  validate_infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    needs: security_scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.3.6'
      
      - name: Validate Terraform
        run: |
          cd terraform/production
          terraform init -backend=false
          terraform validate
      
      - name: Terraform Plan
        run: |
          cd terraform/production
          terraform init
          terraform plan -input=false -out=tfplan
      
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan
          path: terraform/production/tfplan
  
  # Pre-deployment approval gate
  approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [security_scan, validate_infrastructure]
    environment: production-approval
    timeout-minutes: ${{ fromJSON(inputs.approval_timeout) / 60 }}
    steps:
      - name: Get Approval
        run: |
          echo "Production deployment of ${{ inputs.service_name }} approved at $(date -u)"
          echo "Approver: ${{ github.actor }}"
  
  # Pre-warm the production environment
  prepare_environment:
    name: Prepare Production Environment
    runs-on: ubuntu-latest
    needs: approval
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up kubectl
        run: |
          echo "Setting up kubectl..."
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" > kubeconfig.yaml
      
      - name: Verify cluster status
        run: |
          echo "Verifying Kubernetes cluster status..."
          kubectl cluster-info --kubeconfig=kubeconfig.yaml
      
      - name: Pre-warm resources
        run: |
          echo "Pre-warming resources for ${{ inputs.service_name }} deployment..."
          
          # Ensure namespace exists
          kubectl get namespace berrys-production --kubeconfig=kubeconfig.yaml || kubectl create namespace berrys-production --kubeconfig=kubeconfig.yaml
          
          # Pre-scale database connections if needed
          echo "Scaling database connections for increased load..."
          
          # Create or update ConfigMaps
          kubectl apply -f k8s/production/configmaps/ --kubeconfig=kubeconfig.yaml || echo "No ConfigMaps to apply"
  
  # Deploy to production with enhanced monitoring
  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: prepare_environment
    environment: production
    outputs:
      deploy_success: ${{ steps.deployment_status.outputs.success }}
      service_url: ${{ steps.determine_url.outputs.service_url }}
      deployment_id: ${{ steps.prepare_deployment.outputs.deployment_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Prepare deployment
        id: prepare_deployment
        run: |
          # Generate a deployment ID
          DEPLOY_ID="${{ inputs.service_name }}-$(date +%Y%m%d%H%M%S)"
          echo "deployment_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          
          # Record deployment start
          echo "Starting production deployment with ID: $DEPLOY_ID"
          echo "Service: ${{ inputs.service_name }}"
          echo "Strategy: ${{ inputs.deployment_strategy }}"
          echo "Docker image: ${{ inputs.docker_image }}:${{ inputs.docker_tag }}"
      
      - name: Fetch secrets from Vault
        run: |
          echo "Fetching secrets from HashiCorp Vault..."
          
          # Install Vault CLI
          curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
          sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
          sudo apt-get update && sudo apt-get install vault
          
          # Authenticate with Vault
          export VAULT_ADDR=https://vault.berrys.ai
          export VAULT_TOKEN=${{ secrets.VAULT_TOKEN }}
          
          # Fetch secrets for the service
          mkdir -p k8s/production/secrets
          vault kv get -format=json secret/production/${{ inputs.service_name }} | jq -r '.data.data | to_entries | map("\(.key)=\(.value)") | .[]' > k8s/production/secrets/env.txt
          
          echo "Secrets fetched successfully"
      
      - name: Verify Docker image
        run: |
          echo "Verifying Docker image integrity..."
          
          # Pull the image
          docker pull ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
          
          # Scan the image for vulnerabilities
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --severity HIGH,CRITICAL ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
      
      - name: Set up kubectl
        run: |
          echo "Setting up kubectl..."
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" > kubeconfig.yaml
      
      - name: Determine service URL
        id: determine_url
        run: |
          echo "Determining service URL for ${{ inputs.service_name }} in production..."
          
          # Set service URL based on service name
          if [ "${{ inputs.service_name }}" == "api-gateway" ]; then
            echo "service_url=https://api.berrys.ai" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.service_name }}" == "web-dashboard" ]; then
            echo "service_url=https://dashboard.berrys.ai" >> $GITHUB_OUTPUT
          else
            echo "service_url=https://api.berrys.ai/${{ inputs.service_name }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Execute database migrations
        if: inputs.run_migrations
        run: |
          echo "Running database migrations for ${{ inputs.service_name }} in production..."
          
          # Create migration job with deployment ID
          cat > k8s/production/migration-job.yaml << EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${{ inputs.service_name }}-migration-${{ steps.prepare_deployment.outputs.deployment_id }}
            namespace: berrys-production
          spec:
            template:
              spec:
                containers:
                - name: migration
                  image: ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
                  command: ["alembic", "upgrade", "head"]
                  env:
                  - name: ENVIRONMENT
                    value: production
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.service_name }}-secret
                restartPolicy: Never
            backoffLimit: 1
          EOF
          
          # Create migration secret with Vault secrets
          kubectl create secret generic ${{ inputs.service_name }}-secret --from-env-file=k8s/production/secrets/env.txt -n berrys-production --kubeconfig=kubeconfig.yaml
          
          # Apply migration job
          kubectl apply -f k8s/production/migration-job.yaml --kubeconfig=kubeconfig.yaml
          
          # Wait for migration job to complete
          kubectl wait --for=condition=complete job/${{ inputs.service_name }}-migration-${{ steps.prepare_deployment.outputs.deployment_id }} --namespace=berrys-production --timeout=300s --kubeconfig=kubeconfig.yaml
      
      - name: Deploy with Blue-Green strategy
        if: inputs.deployment_strategy == 'blue-green'
        run: |
          echo "Deploying ${{ inputs.service_name }} to production using Blue-Green strategy..."
          
          # Determine active and staging color
          ACTIVE_COLOR=$(kubectl get service ${{ inputs.service_name }} -n berrys-production -o jsonpath='{.spec.selector.color}' --kubeconfig=kubeconfig.yaml || echo "blue")
          
          if [ "$ACTIVE_COLOR" == "blue" ]; then
            NEW_COLOR="green"
          else
            NEW_COLOR="blue"
          fi
          
          echo "Active color: $ACTIVE_COLOR, New color: $NEW_COLOR"
          
          # Create or update the new deployment
          cat > k8s/production/${{ inputs.service_name }}-$NEW_COLOR.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ inputs.service_name }}-$NEW_COLOR
            namespace: berrys-production
            labels:
              app: ${{ inputs.service_name }}
              color: $NEW_COLOR
              deploymentId: ${{ steps.prepare_deployment.outputs.deployment_id }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ inputs.service_name }}
                color: $NEW_COLOR
            template:
              metadata:
                labels:
                  app: ${{ inputs.service_name }}
                  color: $NEW_COLOR
              spec:
                containers:
                - name: ${{ inputs.service_name }}
                  image: ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: ENVIRONMENT
                    value: production
                  - name: DEPLOYMENT_COLOR
                    value: $NEW_COLOR
                  - name: DEPLOYMENT_ID
                    value: ${{ steps.prepare_deployment.outputs.deployment_id }}
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.service_name }}-secret
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 5
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 15
                    periodSeconds: 20
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "512Mi"
                      cpu: "300m"
          EOF
          
          # Apply the new deployment
          kubectl apply -f k8s/production/${{ inputs.service_name }}-$NEW_COLOR.yaml --kubeconfig=kubeconfig.yaml
          
          # Wait for the new deployment to be ready
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ inputs.service_name }}-$NEW_COLOR -n berrys-production --timeout=300s --kubeconfig=kubeconfig.yaml
          
          # Create or update the service to point to the new deployment
          cat > k8s/production/${{ inputs.service_name }}-service.yaml << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ inputs.service_name }}
            namespace: berrys-production
            annotations:
              deployment.kubernetes.io/revision: "${{ steps.prepare_deployment.outputs.deployment_id }}"
          spec:
            selector:
              app: ${{ inputs.service_name }}
              color: $NEW_COLOR
            ports:
            - port: 80
              targetPort: 8000
            type: ClusterIP
          EOF
          
          # Apply the service to switch traffic
          kubectl apply -f k8s/production/${{ inputs.service_name }}-service.yaml --kubeconfig=kubeconfig.yaml
          
          # Wait for the service to stabilize
          sleep 10
          
          echo "Blue-Green deployment completed successfully"
      
      - name: Deploy with Canary strategy
        if: inputs.deployment_strategy == 'canary'
        run: |
          echo "Deploying ${{ inputs.service_name }} to production using Canary strategy with ${{ inputs.canary_percentage }}% traffic..."
          
          # Create stable deployment if it doesn't exist
          kubectl get deployment ${{ inputs.service_name }}-stable -n berrys-production --kubeconfig=kubeconfig.yaml || kubectl create deployment ${{ inputs.service_name }}-stable --image=${{ inputs.docker_image }}:stable -n berrys-production --kubeconfig=kubeconfig.yaml
          
          # Create canary deployment
          cat > k8s/production/${{ inputs.service_name }}-canary.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ inputs.service_name }}-canary
            namespace: berrys-production
            labels:
              app: ${{ inputs.service_name }}
              version: canary
              deploymentId: ${{ steps.prepare_deployment.outputs.deployment_id }}
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: ${{ inputs.service_name }}
                version: canary
            template:
              metadata:
                labels:
                  app: ${{ inputs.service_name }}
                  version: canary
              spec:
                containers:
                - name: ${{ inputs.service_name }}
                  image: ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: ENVIRONMENT
                    value: production
                  - name: DEPLOYMENT_VERSION
                    value: canary
                  - name: DEPLOYMENT_ID
                    value: ${{ steps.prepare_deployment.outputs.deployment_id }}
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.service_name }}-secret
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 5
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 15
                    periodSeconds: 20
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "512Mi"
                      cpu: "300m"
          EOF
          
          # Apply the canary deployment
          kubectl apply -f k8s/production/${{ inputs.service_name }}-canary.yaml --kubeconfig=kubeconfig.yaml
          
          # Wait for the canary deployment to be ready
          echo "Waiting for canary deployment to be ready..."
          kubectl rollout status deployment/${{ inputs.service_name }}-canary -n berrys-production --timeout=300s --kubeconfig=kubeconfig.yaml
          
          # Create or update the service to route traffic between stable and canary
          cat > k8s/production/${{ inputs.service_name }}-service.yaml << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ inputs.service_name }}
            namespace: berrys-production
            annotations:
              deployment.kubernetes.io/revision: "${{ steps.prepare_deployment.outputs.deployment_id }}"
              canary.percentage: "${{ inputs.canary_percentage }}"
          spec:
            selector:
              app: ${{ inputs.service_name }}
            ports:
            - port: 80
              targetPort: 8000
            type: ClusterIP
          EOF
          
          # Apply the service
          kubectl apply -f k8s/production/${{ inputs.service_name }}-service.yaml --kubeconfig=kubeconfig.yaml
          
          # Set up canary routing using Istio
          cat > k8s/production/${{ inputs.service_name }}-vs.yaml << EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: ${{ inputs.service_name }}-vs
            namespace: berrys-production
          spec:
            hosts:
            - ${{ inputs.service_name }}
            http:
            - route:
              - destination:
                  host: ${{ inputs.service_name }}
                  subset: stable
                weight: $((100 - ${{ inputs.canary_percentage }}))
              - destination:
                  host: ${{ inputs.service_name }}
                  subset: canary
                weight: ${{ inputs.canary_percentage }}
          ---
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: ${{ inputs.service_name }}-dr
            namespace: berrys-production
          spec:
            host: ${{ inputs.service_name }}
            subsets:
            - name: stable
              labels:
                app: ${{ inputs.service_name }}
                version: stable
            - name: canary
              labels:
                app: ${{ inputs.service_name }}
                version: canary
          EOF
          
          # Apply the Istio routing configuration
          kubectl apply -f k8s/production/${{ inputs.service_name }}-vs.yaml --kubeconfig=kubeconfig.yaml
          
          echo "Canary deployment with ${{ inputs.canary_percentage }}% traffic completed successfully"
      
      - name: Deploy with Rolling Update strategy
        if: inputs.deployment_strategy == 'rolling'
        run: |
          echo "Deploying ${{ inputs.service_name }} to production using Rolling Update strategy..."
          
          # Create or update the deployment
          cat > k8s/production/${{ inputs.service_name }}-deployment.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ inputs.service_name }}
            namespace: berrys-production
            labels:
              app: ${{ inputs.service_name }}
              deploymentId: ${{ steps.prepare_deployment.outputs.deployment_id }}
          spec:
            replicas: 3
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            selector:
              matchLabels:
                app: ${{ inputs.service_name }}
            template:
              metadata:
                labels:
                  app: ${{ inputs.service_name }}
              spec:
                containers:
                - name: ${{ inputs.service_name }}
                  image: ${{ inputs.docker_image }}:${{ inputs.docker_tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: ENVIRONMENT
                    value: production
                  - name: DEPLOYMENT_ID
                    value: ${{ steps.prepare_deployment.outputs.deployment_id }}
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.service_name }}-secret
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 5
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 15
                    periodSeconds: 20
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "512Mi"
                      cpu: "300m"
          EOF
          
          # Apply the deployment
          kubectl apply -f k8s/production/${{ inputs.service_name }}-deployment.yaml --kubeconfig=kubeconfig.yaml
          
          # Wait for the deployment to be ready
          echo "Waiting for rolling deployment to be ready..."
          kubectl rollout status deployment/${{ inputs.service_name }} -n berrys-production --timeout=300s --kubeconfig=kubeconfig.yaml
          
          # Create or update the service
          cat > k8s/production/${{ inputs.service_name }}-service.yaml << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ inputs.service_name }}
            namespace: berrys-production
            annotations:
              deployment.kubernetes.io/revision: "${{ steps.prepare_deployment.outputs.deployment_id }}"
          spec:
            selector:
              app: ${{ inputs.service_name }}
            ports:
            - port: 80
              targetPort: 8000
            type: ClusterIP
          EOF
          
          # Apply the service
          kubectl apply -f k8s/production/${{ inputs.service_name }}-service.yaml --kubeconfig=kubeconfig.yaml
          
          echo "Rolling update deployment completed successfully"
      
      - name: Verify deployment
        id: verify
        run: |
          echo "Verifying deployment of ${{ inputs.service_name }} to production..."
          
          # Wait for service to be accessible
          MAX_RETRIES=15
          RETRY_INTERVAL=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Verification attempt $i of $MAX_RETRIES..."
            
            # Try to access the health endpoint
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ steps.determine_url.outputs.service_url }}/health" -H "Authorization: Bearer ${{ secrets.API_TOKEN }}")
            
            if [ "$HEALTH_STATUS" == "200" ]; then
              echo "Service is healthy (HTTP $HEALTH_STATUS)!"
              VERIFY_SUCCESS=true
              break
            else
              echo "Service not yet healthy (HTTP $HEALTH_STATUS). Waiting $RETRY_INTERVAL seconds..."
              sleep $RETRY_INTERVAL
            fi
          done
          
          if [ "$VERIFY_SUCCESS" != "true" ]; then
            echo "verification_success=false" >> $GITHUB_OUTPUT
            echo "Failed to verify deployment after $MAX_RETRIES attempts."
            
            if [ "${{ inputs.enable_auto_rollback }}" == "true" ]; then
              echo "Initiating automatic rollback..."
              exit 1
            else
              echo "Auto-rollback is disabled, but deployment verification failed."
              exit 1
            fi
          else
            echo "verification_success=true" >> $GITHUB_OUTPUT
            echo "Deployment verification successful!"
          fi
      
      - name: Monitor production metrics
        run: |
          echo "Monitoring production metrics for ${{ inputs.service_name }}..."
          
          # Wait for metrics to stabilize
          sleep 60
          
          # Get metrics from Prometheus (placeholder for actual implementation)
          echo "Checking performance metrics from Prometheus..."
          
          # Placeholder for metric verification
          echo "Error rate: 0.05% (acceptable threshold: 1%)"
          echo "Latency p95: 150ms (acceptable threshold: 300ms)"
          echo "CPU usage: 25% (acceptable threshold: 70%)"
          echo "Memory usage: 320MB (acceptable threshold: 450MB)"
          
          echo "All metrics within acceptable thresholds"
      
      - name: Record deployment status
        id: deployment_status
        if: always()
        run: |
          echo "Recording deployment status for ${{ inputs.service_name }}..."
          
          if [ "${{ steps.verify.outputs.verification_success }}" == "true" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Deployment of ${{ inputs.service_name }} to production was successful"
            
            # Record successful deployment
            cat > deployment-record.json << EOF
            {
              "service": "${{ inputs.service_name }}",
              "environment": "production",
              "deployment_id": "${{ steps.prepare_deployment.outputs.deployment_id }}",
              "image": "${{ inputs.docker_image }}:${{ inputs.docker_tag }}",
              "strategy": "${{ inputs.deployment_strategy }}",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "status": "success",
              "url": "${{ steps.determine_url.outputs.service_url }}",
              "approver": "${{ github.actor }}"
            }
            EOF
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "Deployment of ${{ inputs.service_name }} to production failed"
            
            # Record failed deployment
            cat > deployment-record.json << EOF
            {
              "service": "${{ inputs.service_name }}",
              "environment": "production",
              "deployment_id": "${{ steps.prepare_deployment.outputs.deployment_id }}",
              "image": "${{ inputs.docker_image }}:${{ inputs.docker_tag }}",
              "strategy": "${{ inputs.deployment_strategy }}",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "status": "failure",
              "url": "${{ steps.determine_url.outputs.service_url }}",
              "approver": "${{ github.actor }}"
            }
            EOF
          fi
      
      - name: Upload deployment record
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: ${{ inputs.service_name }}-production-deployment-record
          path: deployment-record.json
      
      - name: Notify Slack on success
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' --data '{
            "text": "âœ… Production deployment of ${{ inputs.service_name }} succeeded!\nEnvironment: Production\nDeployment ID: ${{ steps.prepare_deployment.outputs.deployment_id }}\nApprover: ${{ github.actor }}\nURL: ${{ steps.determine_url.outputs.service_url }}"
          }' ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify Slack on failure
        if: failure()
        run: |
          curl -X POST -H 'Content-type: application/json' --data '{
            "text": "ðŸš¨ Production deployment of ${{ inputs.service_name }} failed!\nEnvironment: Production\nDeployment ID: ${{ steps.prepare_deployment.outputs.deployment_id }}\nApprover: ${{ github.actor }}\nPlease check deployment logs immediately!"
          }' ${{ secrets.SLACK_WEBHOOK_URL }}
  
  # Automatic rollback on failure
  rollback:
    name: Rollback Production Deployment
    runs-on: ubuntu-latest
    needs: deploy_production
    if: failure() && inputs.enable_auto_rollback == true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up kubectl
        run: |
          echo "Setting up kubectl..."
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" > kubeconfig.yaml
      
      - name: Rollback deployment
        run: |
          echo "Rolling back production deployment of ${{ inputs.service_name }}..."
          
          # Determine rollback strategy based on deployment strategy
          if [ "${{ inputs.deployment_strategy }}" == "blue-green" ]; then
            echo "Performing Blue-Green rollback..."
            
            # Get current and previous colors
            CURRENT_COLOR=$(kubectl get service ${{ inputs.service_name }} -n berrys-production -o jsonpath='{.spec.selector.color}' --kubeconfig=kubeconfig.yaml)
            
            if [ "$CURRENT_COLOR" == "blue" ]; then
              PREVIOUS_COLOR="green"
            else
              PREVIOUS_COLOR="blue"
            fi
            
            echo "Current color: $CURRENT_COLOR, Previous color: $PREVIOUS_COLOR"
            
            # Switch service back to previous deployment
            kubectl patch service ${{ inputs.service_name }} -n berrys-production --type=json -p='[{"op": "replace", "path": "/spec/selector/color", "value":"'$PREVIOUS_COLOR'"}]' --kubeconfig=kubeconfig.yaml
            
          elif [ "${{ inputs.deployment_strategy }}" == "canary" ]; then
            echo "Performing Canary rollback..."
            
            # Delete canary deployment
            kubectl delete deployment ${{ inputs.service_name }}-canary -n berrys-production --kubeconfig=kubeconfig.yaml
            
            # Update Istio VirtualService to route 100% to stable
            kubectl patch virtualservice ${{ inputs.service_name }}-vs -n berrys-production --type=json -p='[{"op": "replace", "path": "/spec/http/0/route/0/weight", "value": 100}, {"op": "replace", "path": "/spec/http/0/route/1/weight", "value": 0}]' --kubeconfig=kubeconfig.yaml
            
          else
            echo "Performing Rolling Update rollback..."
            
            # Rollback to the previous revision
